float ShadowRayCast( Ray ray,
                     int exceptType,
                     int exceptIndex,
                     int numOfSphere,
                     StructuredBuffer<RTSphere> spheres,
                     int numOfTriangle,
                     StructuredBuffer<RTTriangle> triangles) 
{
    RayHit record = CreateRayHit();

    for (int i = 0; i < numOfSphere; i++)
    {
        if (exceptType == 0 && exceptIndex == i)
        {
            continue;
        }
            
        IntersectSphere(ray, record, spheres[i], i);
        
        if (record.GeoType != -1)
        {
            return 0;
        }
    }

    for (int t = 0; t < numOfTriangle; t++)
    {
        if (exceptType == 1 && exceptIndex == t)
        {
            continue;
        }

        IntersectTriangle(ray, record, triangles[t], t);

        if (record.GeoType != -1)
        {
            return 0;
        }
    }

    return 1;

}

float SoftShadow(RayHit hit,
                 int MapIndex,
                 RTSpotLight spot,
                 Texture2DArray<float4> shadowMap,
                 RTSpotLight_UW shadowUtility)
{
    float3 ray = hit.position - spot.position;
    float dis = length(ray);
    ray = normalize(ray);

    float cos = dot(ray, -spot.direction);
    float3 pointP = spot.position + (10 / cos) * ray;

    float dw = dot(pointP - shadowUtility.Pref, shadowUtility.W);
    float du = dot(pointP - shadowUtility.Pref, shadowUtility.U);

    int i = (int) (du / shadowUtility.PixelSize);
    int j = (int) (dw / shadowUtility.PixelSize);

    uint3 id = uint3(i, j, MapIndex);
    float4 map = shadowMap[id.xyz];

    if (dis > map.x)
    {
        if (map.y == hit.GeoType && map.z == hit.GeoIndex)
        {
            return 1;
        }
        return 0;
    }

    return 1;
}

// position: visible point position
// lightType: 0 ---> Directional
//            1 ---> Point
//            2 ---> Spot 
// lightPosition: The position of point and spot light
// direction: The diretion of direction and spot light 
// ExceptType : Will ignore the index to prevent self shadow
//            0 ---> Sphere
//            1 ---> Triangle
// ExcepteIndex: index the of object
float HardShadow(
    float3 position,
    int lightType,
    float3 lightPosition,
    float3 direction,
    int exceptType,
    int exceptIndex,
    int numOfSphere,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles)
{
    Ray ray;
    float result;

    if (lightType == 0) // directional light
    {
        ray = CreateRay(position, direction);

    } else if (lightType == 1) { // point light

        float3 dir = normalize(lightPosition - position);
        ray = CreateRay(position, dir);

    } else if (lightType == 2) { // spot light

        float3 dir = normalize(lightPosition - position);
        ray = CreateRay(position, dir);
        
    }

    result = ShadowRayCast(ray, exceptType, exceptIndex, numOfSphere, spheres, numOfTriangle, triangles);
    return result;
}
