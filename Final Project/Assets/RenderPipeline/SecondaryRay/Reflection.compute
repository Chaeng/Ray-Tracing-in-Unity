#include "../RayCasting/Trace.compute"

float3 Reflection(
    int maxHit,
    float3 result,
    inout Ray ray, 
    RayHit hit, 
    float3 ambientLightUpper,
    float3 ambientLightLower,
    int numOfDirLight,
    StructuredBuffer<RTDirectionalLight> dirLights,
    int numOfPointLight,
    StructuredBuffer<RTPointLight> pointLights,
    int numOfSpotLight,
    StructuredBuffer<RTSpotLight> spotLights,
    Texture2D<float4> skybox, 
    SamplerState skyboxSampler,
    int numOfSpheres,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles,
    Texture2DArray<float4> shadowMap,
    StructuredBuffer<RTSpotLight_UW> shadowUtility,
    float fogFactor,
    float3 fogColor,
    int numOfMaterials,
    StructuredBuffer<RTMaterial> materials)
{
    // Hard code
    // Request parser to add 
    // - World
    //    - maxHit
    // - Material
    //    - reflective index
	float refl = 0.2;
	float k = 1 - refl;
    float3 final_reflColor = float3(0, 0, 0);
    
    // if geometry
    if (hit.distance < 1.#INF)
    {   
         int numHit = 0;
         Ray curRay = ray;
         RayHit curHit = hit;
                
         while(numHit < maxHit && curHit.distance < 1.#INF){
         
             float3 hitNml = normalize(curHit.normal);
             float3 rayNml = normalize(curRay.direction);
             float3 reflectDir =  reflect(rayNml, hitNml); 
             Ray newRay = CreateRay(curHit.position, reflectDir);
             curRay = newRay;
             RayHit newHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
             curHit = newHit;
             numHit++;
         }
         
         if(numHit == 1)
         {
             float theta = acos(curRay.direction.y) / -PI;
             float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
             return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
 
         } else if(numHit == 2){
             //reset ray and rayhit
             curRay = ray;
             curHit = hit;
         
             Ray rayArr[3];
             rayArr[0] = CreateRay(curHit.position, curRay.direction);
             rayArr[1] = CreateRay(hit.position, curRay.direction);
             rayArr[2] = CreateRay(hit.position, curRay.direction);
             
             RayHit hitArr[3];
             hitArr[0] = curHit;
             hitArr[1] = CreateRayHit();
             hitArr[2] = CreateRayHit();
                       
             int count = 1;
             while(count <= 2){
                           
                  float3 hitNml = normalize(curHit.normal);
                  float3 rayNml = normalize(curRay.direction);
                  float3 reflectDir =  reflect(rayNml, hitNml); 
                  Ray newRay = CreateRay(curHit.position, reflectDir);
                  rayArr[count] = newRay;
                  curRay = newRay;
                  RayHit newHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                  hitArr[count] = newHit;
                  curHit = newHit;
                  count++;
             }
             
             float theta = acos(curRay.direction.y) / -PI;
             float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
             
             float3 colorArr[2];
             colorArr[0] = float3(0, 0, 0);
             colorArr[1] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
             
             for(int i = 0; i >= 0; --i){
                 float3 color = Shade(
                                rayArr[i], 
                                hitArr[i], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                 colorArr[i] += color;    
             }     
            return colorArr[1] + (colorArr[0] * k); 
         } else if(numHit == 3){
             //reset ray and rayhit
             curRay = ray;
             curHit = hit;
         
             Ray rayArr[4];
             rayArr[0] = CreateRay(curHit.position, curRay.direction);
             rayArr[1] = CreateRay(hit.position, curRay.direction);
             rayArr[2] = CreateRay(hit.position, curRay.direction);
             rayArr[3] = CreateRay(hit.position, curRay.direction);
             
             RayHit hitArr[4];
             hitArr[0] = curHit;
             hitArr[1] = CreateRayHit();
             hitArr[2] = CreateRayHit();
             hitArr[3] = CreateRayHit();
                       
             int count = 1;
             while(count <= 3){
                           
                  float3 hitNml = normalize(curHit.normal);
                  float3 rayNml = normalize(curRay.direction);
                  float3 reflectDir =  reflect(rayNml, hitNml); 
                  Ray newRay = CreateRay(curHit.position, reflectDir);
                  rayArr[count] = newRay;
                  curRay = newRay;
                  RayHit newHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                  hitArr[count] = newHit;
                  curHit = newHit;
                  count++;
             }
             
             float theta = acos(curRay.direction.y) / -PI;
             float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
             
             float3 colorArr[4];
             colorArr[0] = float3(0, 0, 0);
             colorArr[1] = float3(0, 0, 0);
             colorArr[2] = float3(0, 0, 0);
             colorArr[3] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
             
             for(int i = 2; i > 0; --i){
                 float3 color = Shade(
                                rayArr[i], 
                                hitArr[i], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                 colorArr[i] = color;    
             }     
            return colorArr[3] + ((colorArr[2] + (colorArr[1] * k)) * k); 
         } else if (numHit == 4){
                          //reset ray and rayhit
             curRay = ray;
             curHit = hit;
         
             Ray rayArr[4];
             rayArr[0] = CreateRay(curHit.position, curRay.direction);
             rayArr[1] = CreateRay(hit.position, curRay.direction);
             rayArr[2] = CreateRay(hit.position, curRay.direction);
             rayArr[3] = CreateRay(hit.position, curRay.direction);
             
             RayHit hitArr[4];
             hitArr[0] = curHit;
             hitArr[1] = CreateRayHit();
             hitArr[2] = CreateRayHit();
             hitArr[3] = CreateRayHit();
                       
             int count = 1;
             while(count <= 3){
                           
                  float3 hitNml = normalize(curHit.normal);
                  float3 rayNml = normalize(curRay.direction);
                  float3 reflectDir =  reflect(rayNml, hitNml); 
                  Ray newRay = CreateRay(curHit.position, reflectDir);
                  rayArr[count] = newRay;
                  curRay = newRay;
                  RayHit newHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                  hitArr[count] = newHit;
                  curHit = newHit;
                  count++;
             }
             
             float theta = acos(curRay.direction.y) / -PI;
             float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
             
             float3 colorArr[4];
             colorArr[0] = float3(0, 0, 0);
             colorArr[1] = float3(0, 0, 0);
             colorArr[2] = float3(0, 0, 0);
             colorArr[3] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
             
             for(int i = 2; i > 0; --i){
                 float3 color = Shade(
                                rayArr[i], 
                                hitArr[i], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                 colorArr[i] = color;    
             }     
            return colorArr[3] + ((colorArr[2] + (colorArr[1] * k)) * k); 
         } else {
             //reset ray and rayhit
             curRay = ray;
             curHit = hit;
             int numHit = 0;
             while(numHit < maxHit && curHit.distance < 1.#INF){
             
                 float3 hitNml = normalize(curHit.normal);
                 float3 rayNml = normalize(curRay.direction);
                 float3 reflectDir =  reflect(rayNml, hitNml); 
                 Ray newRay = CreateRay(curHit.position, reflectDir);
                 curRay = newRay;
                 RayHit newHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                 curHit = newHit;
                 numHit++;
             }
             
             float theta = acos(curRay.direction.y) / -PI;
             float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
             return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
         } 
    }  
    else {

        // if not a geometry, it must be a skybox
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;   
    }	
}


