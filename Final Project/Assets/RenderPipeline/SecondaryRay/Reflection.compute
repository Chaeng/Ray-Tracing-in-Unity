float3 Reflection(
	inout Ray ray,
	RayHit hit,
	float3 ambientColor,
	int numOfDirLight,
	StructuredBuffer<RTDirectionalLight> dirLights,
	int numOfPointLight,
	StructuredBuffer<RTPointLight> pointLights,
	Texture2D<float4> skybox,
	SamplerState skyboxSampler)
{

/*
  Need to add
  
  - int Generation
  - bool reflectEffect
  - Obj[] obj (to check all hit object)
	;*/
	 
    int mGen = 1;
	float3 reflectResult[3];
	bool reflectEffect = true;
	float trans = 0;
	float refl = 0.5;
	float k = 1 - refl - trans;
	
	float3 skyboxResult = Shade(ray, hit, ambientColor, numOfDirLight, dirLights, numOfPointLight, pointLights, skybox, skyboxSampler);
	float3 result = float3(0, 0, 0);
	float3 finalResult = float3(0, 0, 0);
	
	// TODO: Return result
	// if mGen = 1, iterate 3 times => 0th and 1st for r&t, 2nd for Phong
	if(hit.distance < 1.#INF && reflectEffect == true){
	/*
	    for(int i = 0; i< (mGen + 2); i++){
	        result = Shade(ray, hit, ambientColor, numOfDirLight, dirLights, skybox, skyboxSampler);    
	        result *= k;  
	        int indx = (mGen + 1 - i);
	        reflectResult[indx] = result;
	    }
       
        //for(int i = 0; i < mGen + 2; ++i){
        
            // TODO: Compute Phong
            /*
            result = Shade(ray, hit, ambientColor, numOfDirLight, dirLights, skybox, skyboxSampler);
            result *= k;
            reflectResult[mGen + 2 - i] = result;
            
            if(i < mGen + 1){                       
                //if(){
               // TODO: Compute reflection
                //}	    
               // TODO: result*k + reflection          
            }*/
        //}
        // TODO: compute result
        /*
        finalResult += (colorArray[mGen + 2 - 0] * k); // k will need to be array later
        for(int i = mGen + 2 - 1; i >= 0; --i){
           finalResult = (finalResult * k) + (reflectResult[i] * refl[i]);
        }*/
	    return skyboxResult;//float3(1, 0.5, 0.5);
	} 
	return skyboxResult; //float3(0.1, 0.1, 0.1);
}

