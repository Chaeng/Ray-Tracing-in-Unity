#ifndef TRANSPARENT_COMPUTE
#define TRANSPARENT_COMPUTE

#include "SphereInternalIntersect.compute"
#include "RTSphere.compute"
#include "RefractRay.compute"
#include "GetTriangleNormal.compute"

float3 Transparent(
    int maxHit,
    float3 result,
    inout Ray ray, 
    RayHit hit, 
    float3 ambientLightUpper,
    float3 ambientLightLower,
    int numOfDirLight,
    StructuredBuffer<RTDirectionalLight> dirLights,
    int numOfPointLight,
    StructuredBuffer<RTPointLight> pointLights,
    int numOfSpotLight,
    StructuredBuffer<RTSpotLight> spotLights,
    Texture2D<float4> skybox, 
    SamplerState skyboxSampler,
    int numOfSpheres,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles,
    Texture2DArray<float4> shadowMap,
    StructuredBuffer<RTSpotLight_UW> shadowUtility,
    float fogFactor,
    float3 fogColor,
    int numOfMaterials,
    StructuredBuffer<RTMaterial> materials)
{
    if (hit.distance < 1.#INF)
    {                

             // hardcode
             float refIndex = 1.52; // glass
             float air_refIndex = 1.0003;
             float triAngleRefractiveIndex = 1.52;
             
             // hard code
             float tranparency = 0.8f;
             
             float diamondIndex = 2.42;
             float crystalIndex = 2.42;
              //float crystalIndex = 1.54259;
             float glassIndex = 1.52;
                   
             int numHit = 0;
             Ray curRay = ray;

             RayHit curHit = hit;;
             float n1 = air_refIndex;
             float n2 = air_refIndex;
             float3 cur_V = -normalize(curRay.direction);
             
             Ray outRay;
             RayHit transRayHit = CreateRayHit();
             while(numHit <= maxHit && curHit.distance < 1.#INF) {
                 //SphereInternalIntersect(RayHit curHit, Ray refrectRay, int numOfSphere,  StructuredBuffer<RTSphere> spheres, int targetId)
                 if(curHit.geoType == 0){ // sphere
                     n2 = crystalIndex;
                     Ray internalRefract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                     RayHit internalHit = SphereInternalIntersect(curHit, internalRefract, numOfSpheres, spheres, curHit.geoIndex);
                     cur_V = -normalize(internalRefract.direction);
                     curRay = RefractRay(internalHit, cur_V, internalHit.normal, n2, n1);
                     curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);  
                     numHit++;
                 } else if(curHit.geoType == 1){ // Triangle
                     n2 = glassIndex;              
   
                     float3 triAngleNormal = float3(0, 0, 0);
                     triAngleNormal = GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                     
                     if(dot(cur_V, curHit.normal) > 0 ){               
                         curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the front
                     } else {                              
                         curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the back
                     }
                     curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);       
                 } 
                 cur_V = -normalize(curRay.direction);   
                 n1 = n2;
                 numHit++;
             }
             
             if(numHit == 1 && numHit <= maxHit) {
                    
                float theta = acos(curRay.direction.y) / -PI;
                float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                float3 c1 = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
                return (result * (1 - tranparency))  + (c1 * tranparency); 
                
             } else if(numHit ==  2 && numHit <= maxHit) {
             
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;

                cur_V = -normalize(curRay.direction);
                
                Ray rayArr[3];
                for(int i = 0; i < 3; ++i){
                   rayArr[i] = CreateRay(curHit.position, curRay.direction);
                }
                     
                RayHit hitArr[3];
                hitArr[0] = curHit;
                for(int j = 1; j < 3; ++j){
                   hitArr[j] = CreateRayHit();
                }
                
                 if(curHit.geoType == 0){ // numHit = 2
                     
                     n2 = crystalIndex;                  
                     int count = 1; 
                     // first iteration  
                     Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                     rayArr[count] = refract;
                     RayHit internalHit = CreateRayHit();
                     internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                     hitArr[count] = internalHit;
                         
                     // second iteration
                     count++;
                     
                     Ray refractOut = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                     Ray newRayOut = CreateRay(internalHit.position, normalize(refractOut.direction));
                     rayArr[count] = newRayOut;
                     curRay = newRayOut;
                     cur_V = -normalize(curRay.direction);
                 
                     RayHit r2 = CreateRayHit();
                     r2 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = r2;
                     hitArr[count] = curHit;
                     
                 } else { // must be 2 triangle
                   
                   // numHit = 2
                   n1 = air_refIndex;
                   n2 = glassIndex;
                   
                   int countT = 1;
                   while(countT <= numHit){     
                              
                        if(n1 == n2){
                             n1 = glassIndex;
                             n2 = air_refIndex;
                        }      
                        
                        float3 i2_triangleNormal = float3(0, 0, 0);
                        i2_triangleNormal += GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);

                        if(dot(cur_V, i2_triangleNormal) > 0 ){               
                            curRay = RefractRay(curHit, cur_V, i2_triangleNormal, n1, n2);// hit from the front
                        } else {                            
                            curRay = RefractRay(curHit, cur_V, -i2_triangleNormal, n1, n2);// hit from the back
                        }
                        rayArr[countT] = curRay;
                        cur_V = -normalize(curRay.direction);
                        
                        RayHit rayHitMaxHit3 = CreateRayHit();
                        rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                        curHit = rayHitMaxHit3;
                        hitArr[countT] = curHit;  
                           
                        n1 = n2;
                        countT++;
                     }
                 } 
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 
                 float3 colorArr[3];
                 colorArr[0] = float3(0, 0, 0);
                 colorArr[1] = float3(0, 0, 0);
                 colorArr[2] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz; 
                 
                 for(int i3 = 0; i3 < 3; ++i3){
                     float3 color = Shade(
                                    rayArr[i3], 
                                    hitArr[i3], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                                    fogColor,
                                    numOfMaterials,
                                    materials);
                     colorArr[0] += color;
                 }
                 float3 c2 = colorArr[2] * (1 - tranparency);
                 float3 c1 = (colorArr[1] * (1 - tranparency)) + (c2 * tranparency);
                 float3 c0 = (colorArr[0] * (1 - tranparency)) + (c1 * tranparency);
                 return (result * (1 - tranparency)) + (c0 * tranparency);
 
             } else if (numHit == 3 && numHit <= maxHit) {
             
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[4];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 4; ++i){
                     rayArr[i] = CreateRay(curHit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[4];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 4; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count <= numHit){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = curHit;
                         
                     } else if(curHit.geoType == 1){
                         if(n1 == n2){
                            n1 = air_refIndex;
                            n2 = glassIndex;
                         } else {
                            n2 = glassIndex;
                         }
                         float3 i3_triangleNormal = float3(0, 0, 0);
                         i3_triangleNormal += GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                         
                         RayHit rayHitMaxHit3;
                         if(dot(cur_V, i3_triangleNormal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, i3_triangleNormal, n1, n2);// hit from the front
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -i3_triangleNormal, n1, n2);// hit from the back
                         }

                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                     }
                     n1 = n2;
                     count++;
                 }
                
                 float3 colorArr[4]; 
                 for(int index = 0; index < 4; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[3] += (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);

                 for(int k = 0; k < 3; ++k){
                     float3 color = Shade(
                                rayArr[k], 
                                hitArr[k], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] += color; 
                 }   
        
                   
                float3 c3 =  colorArr[3];
                float3 c2 =  (colorArr[2] * (1 - tranparency)) + c3;
                float3 c1 =  (colorArr[1] * (1 - tranparency)) + (c2 * tranparency);
                float3 c0 = (colorArr[0] * (1 - tranparency)) + (c1 * tranparency);
                return (result * (1 - tranparency)) + (c0 * tranparency);  
                
             } else if (numHit <= maxHit && numHit == 4){
                 
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[5];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 5; i++){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[5];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 5; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count <= numHit){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = internalHit;
                         
                     } else if(curHit.geoType == 1){
                         n2 = glassIndex;
                         
                         float3 i4_triAngleNormal = float3(0, 0, 0);
                         i4_triAngleNormal = GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                         
                         if(dot(cur_V, i4_triAngleNormal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, i4_triAngleNormal, n1, n2);// hit from the front
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -i4_triAngleNormal, n1, n2);// hit from the back
                         }
                         rayArr[count] = curRay;
                         
                         RayHit rayHitMaxHit3  = CreateRayHit();
                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         hitArr[count] = curHit;      
                     }
                     count++;
                 }
                
                 float3 colorArr[5]; 
                 for(int index = 0; index < 5; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[4] += (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);
              

                 for(int k = 0; k < 4; ++k){
                     float3 color = Shade(
                                rayArr[k], 
                                hitArr[k], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] += color; 
                 }  
             
                float3 c3 =  colorArr[3];
                float3 c2 =  (colorArr[2] * (1 - tranparency)) + c3;
                float3 c1 =  (colorArr[1] * (1 - tranparency)) + (c2 * tranparency);
                float3 c0 =  (colorArr[0] * (1 - tranparency)) + (c2 * tranparency);
                return c0;  
             } else if(numHit <= maxHit && numHit == 5){
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[6];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 6; ++i){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[6];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 6; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count < 6){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = curHit;
                         
                     } else if(curHit.geoType == 1){ // triangle
                         if(n1 == n2){
                             n1 = air_refIndex;
                             n2 = glassIndex;
                         } else {
                             n2 = glassIndex;
                         }
                     
                         float3 i5_triAngleNormal = GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                         
                         if(dot(cur_V, i5_triAngleNormal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, i5_triAngleNormal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -i5_triAngleNormal, n1, n2);// hit from the front
                         }
                         cur_V = -normalize(curRay.direction);
                         rayArr[count] = curRay;
                         
                         RayHit rayHitMaxHit3 = CreateRayHit();
                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);                         
                         curHit = rayHitMaxHit3;
                         hitArr[count] = curHit;             
                     }
                     n1 = n2;
                     count++;
                 }
                
                 float3 colorArr[6]; 
                 for(int index = 0; index < 4; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[5] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);
              
                 for(int k = 0; k < 5; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                                    fogColor,
                                    numOfMaterials,
                                    materials);
                     colorArr[k] = color;    
                 }  
                 float3 c5 = colorArr[5]; // skybox
                 float3 c4 = (colorArr[4] *(1 - tranparency)) + (c5 * tranparency);
                 float3 c3 = (colorArr[3] *(1 - tranparency)) + (c4 * tranparency);
                 float3 c2 = (colorArr[2] *(1 - tranparency)) + (c3 * tranparency);
                 float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 float3 c0 = (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
                 return (result *(1 - tranparency)) + (c0 * tranparency);
             } else if (numHit <= maxHit && numHit == 6){ // maxHit is 6
             
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[7];
                 for(int i = 0; i < 7; ++i){
                     rayArr[i] = CreateRay(curHit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[7];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 7; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count < 7){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = curHit;
                         
                     } else if(curHit.geoType == 1){ // triangle
                         if(n1 == n2){
                             n1 = air_refIndex;
                             n2 = glassIndex;
                         } else {
                             n2 = glassIndex;
                         }
                     
                         float3 i5_triAngleNormal = GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                         
                         if(dot(cur_V, i5_triAngleNormal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, i5_triAngleNormal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -i5_triAngleNormal, n1, n2);// hit from the front
                         }
                         cur_V = -normalize(curRay.direction);
                         rayArr[count] = curRay;
                         
                         RayHit rayHitMaxHit3 = CreateRayHit();
                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);                         
                         curHit = rayHitMaxHit3;
                         hitArr[count] = curHit;             
                     }
                     n1 = n2;
                     count++;
                 }
                
                 float3 colorArr[7]; 
                 for(int index = 0; index < 6; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[6] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);
              
                 for(int k = 0; k < 6; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                                    fogColor,
                                    numOfMaterials,
                                    materials);
                     colorArr[k] = color;    
                 }  
                 float3 c6 = colorArr[6]; // skybox
                 float3 c5 = (colorArr[5] *(1 - tranparency)) + (c6 * tranparency);
                 float3 c4 = (colorArr[4] *(1 - tranparency)) + (c5 * tranparency);
                 float3 c3 = (colorArr[3] *(1 - tranparency)) + (c4 * tranparency);
                 float3 c2 = (colorArr[2] *(1 - tranparency)) + (c3 * tranparency);
                 float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 float3 c0 = (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
                 return (result *(1 - tranparency)) + (c0 * tranparency);
             } else if(numHit <= maxHit && numHit == 7){ // maxHit is 7
             
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[8];
                 for(int i = 0; i < 8; ++i){
                     rayArr[i] = CreateRay(curHit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[8];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 8; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count < 8){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = curHit;
                         
                     } else if(curHit.geoType == 1){ // triangle
                         if(n1 == n2){
                             n1 = air_refIndex;
                             n2 = glassIndex;
                         } else {
                             n2 = glassIndex;
                         }
                     
                         float3 i5_triAngleNormal = GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                         
                         if(dot(cur_V, i5_triAngleNormal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, i5_triAngleNormal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -i5_triAngleNormal, n1, n2);// hit from the front
                         }
                         cur_V = -normalize(curRay.direction);
                         rayArr[count] = curRay;
                         
                         RayHit rayHitMaxHit3 = CreateRayHit();
                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);                         
                         curHit = rayHitMaxHit3;
                         hitArr[count] = curHit;             
                     }
                     n1 = n2;
                     count++;
                 }
                
                 float3 colorArr[8]; 
                 for(int index = 0; index < 7; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[7] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);
              
                 for(int k = 0; k < 7; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                                    fogColor,
                                    numOfMaterials,
                                    materials);
                     colorArr[k] = color;    
                 } 
                 float3 c7 = colorArr[7]; // skybox 
                 float3 c6 = (colorArr[6] *(1 - tranparency)) + (c7 * tranparency);
                 float3 c5 = (colorArr[5] *(1 - tranparency)) + (c6 * tranparency);
                 float3 c4 = (colorArr[4] *(1 - tranparency)) + (c5 * tranparency);
                 float3 c3 = (colorArr[3] *(1 - tranparency)) + (c4 * tranparency);
                 float3 c2 = (colorArr[2] *(1 - tranparency)) + (c3 * tranparency);
                 float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 float3 c0 = (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
                 return (result *(1 - tranparency)) + (c0 * tranparency);
             } else { // maxHit is 8
             
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[9];
                 for(int i = 0; i < 9; ++i){
                     rayArr[i] = CreateRay(curHit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[9];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 9; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count < 9){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = curHit;
                         
                     } else if(curHit.geoType == 1){ // triangle
                         if(n1 == n2){
                             n1 = air_refIndex;
                             n2 = glassIndex;
                         } else {
                             n2 = glassIndex;
                         }
                     
                         float3 i5_triAngleNormal = GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                         
                         if(dot(cur_V, i5_triAngleNormal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, i5_triAngleNormal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -i5_triAngleNormal, n1, n2);// hit from the front
                         }
                         cur_V = -normalize(curRay.direction);
                         rayArr[count] = curRay;
                         
                         RayHit rayHitMaxHit3 = CreateRayHit();
                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);                         
                         curHit = rayHitMaxHit3;
                         hitArr[count] = curHit;             
                     }
                     n1 = n2;
                     count++;
                 }
                
                 float3 colorArr[9]; 
                 for(int index = 0; index < 8; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[8] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);
              
                 for(int k = 0; k < 8; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                                    fogColor,
                                    numOfMaterials,
                                    materials);
                     colorArr[k] = color;    
                 } 
                 float3 c8 = colorArr[8]; // skybox 
                 float3 c7 = (colorArr[7] *(1 - tranparency)) + (c8 * tranparency);
                 float3 c6 = (colorArr[6] *(1 - tranparency)) + (c7 * tranparency);
                 float3 c5 = (colorArr[5] *(1 - tranparency)) + (c6 * tranparency);
                 float3 c4 = (colorArr[4] *(1 - tranparency)) + (c5 * tranparency);
                 float3 c3 = (colorArr[3] *(1 - tranparency)) + (c4 * tranparency);
                 float3 c2 = (colorArr[2] *(1 - tranparency)) + (c3 * tranparency);
                 float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 float3 c0 = (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
                 return (result *(1 - tranparency)) + (c0 * tranparency);
             }
          
    } else {
    
            // if not a geometry, it must be a skybox
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;   
    }
}

#endif // TRANSPARENT_COMPUTE
