#ifndef TRANSPARENT_COMPUTE
#define TRANSPARENT_COMPUTE
#include "SphereInternalIntersect.compute"
#include "RTSphere.compute"
#include "RefractRay.compute"
#include "GetTriangleNormal.compute"

float3 Transparent(
    int maxHit,
    float3 result,
    inout Ray ray, 
    RayHit hit, 
    float3 ambientLightUpper,
    float3 ambientLightLower,
    int numOfDirLight,
    StructuredBuffer<RTDirectionalLight> dirLights,
    int numOfPointLight,
    StructuredBuffer<RTPointLight> pointLights,
    int numOfSpotLight,
    StructuredBuffer<RTSpotLight> spotLights,
    Texture2D<float4> skybox, 
    SamplerState skyboxSampler,
    int numOfSpheres,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles,
    Texture2DArray<float4> shadowMap,
    StructuredBuffer<RTSpotLight_UW> shadowUtility,
    float fogFactor,
    float3 fogColor,
    int numOfMaterials,
    StructuredBuffer<RTMaterial> materials)
{
    if (hit.distance < 1.#INF)
    {                
             int maxRefractHit = 6; // hardcode

             // hardcode
             float refIndex = 1.52; // glass
             float air_refIndex = 1.0003;
             float triAngleRefractiveIndex = 1.52;
             
             // hard code
             float tranparency = 0.8f;
             
             float diamondIndex = 2.42;
             float crystalIndex = 2.42;
              //float crystalIndex = 1.54259;
             float glassIndex = 1.52;
                   
             int numHit = 0;
             Ray curRay = ray;

             RayHit curHit = hit;;
             float n1 = air_refIndex;
             float n2 = air_refIndex;
             float3 cur_V = -normalize(curRay.direction);
             
             Ray outRay;
             RayHit transRayHit = CreateRayHit();
             while(numHit <= maxRefractHit && curHit.distance < 1.#INF) {
                 //SphereInternalIntersect(RayHit curHit, Ray refrectRay, int numOfSphere,  StructuredBuffer<RTSphere> spheres, int targetId)
                 if(curHit.geoType == 0){ // sphere
                     n2 = crystalIndex;
                     Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                     RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                     cur_V = -normalize(refract.direction);
                     curRay = RefractRay(internalHit, cur_V, internalHit.normal, n2, n1);
                     curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, 0);  
                     numHit++;
                 } else if(curHit.geoType == 1){ // Triangle
                     n2 = glassIndex;              
   
                     float3 triAngleNormal = float3(0, 0, 0);
                     triAngleNormal = GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);
                     
                     if(dot(cur_V, curHit.normal) > 0 ){               
                         curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the front
                     } else {                              
                         curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the back
                     }
                     curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);       
                 } 
                 cur_V = -normalize(curRay.direction);   
                 n1 = n2;
                 numHit++;
             }
             
             if(numHit == 1 && numHit <= maxHit) {
      
                 float3 color =     Shade(
                                    ray, 
                                    hit, 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                                    fogColor,
                                    numOfMaterials,
                                    materials);
                    
                float theta = acos(curRay.direction.y) / -PI;
                float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                return (color * (1 - tranparency))  + (tranparency)*skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz; 
                
             } else if(numHit ==  2 && numHit <= maxHit) {
             
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;

                cur_V = -normalize(curRay.direction);
                
                Ray rayArr[3];
                for(int i = 0; i < 3; ++i){
                   rayArr[i] = CreateRay(curHit.position, curRay.direction);
                }
                     
                RayHit hitArr[3];
                hitArr[0] = curHit;
                for(int j = 1; j < 3; ++j){
                   hitArr[j] = CreateRayHit();
                }
                
                 if(curHit.geoType == 0){
                     
                     n2 = crystalIndex;                  
                     int count = 1; 
                     // first iteration  
                     Ray refract = RefractRay(curHit, cur_V, normalize(curHit.normal), n1, n2);
                     rayArr[count] = refract;
                     RayHit internalHit = CreateRayHit();
                     internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                     hitArr[count] = internalHit;
                         
                     // second iteration
                     count++;
                     //curRay = RefractRay(internalHit, normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                     Ray refractOut = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                     Ray newRayOut = CreateRay(internalHit.position, normalize(refractOut.direction));
                     rayArr[count] = newRayOut;
                     curRay = newRayOut;
                     cur_V = -normalize(curRay.direction);
                 
                     RayHit r2 = CreateRayHit();
                     r2 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = r2;
                     hitArr[count] = curHit;
                     
                 } else { // must be 2 triangle
                    
                   n1 = air_refIndex;
                   n2 = glassIndex;
                   int countT = 0;
                   while(countT <= numHit){
                       
                        if(countT == numHit){
                             n1 = glassIndex;
                             n2 = air_refIndex;
                        }  
                           
                        RayHit rayHitMaxHit3 = CreateRayHit();
                        float3 i2_triangleNormal = float3(0, 0, 0);
                        i2_triangleNormal += GetTriangleNormal(numOfTriangle, triangles, curHit.geoIndex);

                        if(dot(cur_V, i2_triangleNormal) > 0 ){               
                            curRay = RefractRay(curHit, cur_V, i2_triangleNormal, n1, n2);// hit from the front
                        } else {                            
                            curRay = RefractRay(curHit, cur_V, -i2_triangleNormal, n1, n2);// hit from the back
                        }
                        rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                        cur_V = -normalize(curRay.direction);
                        curHit = rayHitMaxHit3;
                        rayArr[countT] = curRay;
                        hitArr[countT] = curHit;  
                        n1 = n2;
                        countT++;
                     }
                 } 
                
                // if a sphere
                /*
                TODO: Chaeng fix this
                if(curHit.geoType == 0){
                     
                     n2 = crystalIndex;             
                     int count = 1;
                      
                     // first iteration  
                     Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                     rayArr[count] = refract;
                     RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                     hitArr[count] = internalHit;
                         
                     // second iteration
                     count++;
                     curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                     rayArr[count] = curRay;
                     cur_V = -normalize(curRay.direction);
                     
                     RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = transRayHit;
                     hitArr[count] = curHit;
                     count++;
                 } 
                 */
   
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 
                 float3 colorArr[2];
                 colorArr[0] = result;//float3(0, 0, 0);
                 colorArr[1] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz; 
                 float3 color = Shade(
                                rayArr[1], 
                                hitArr[1], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                 colorArr[0] += color;
                 return colorArr[0] + ((1.0003/refIndex) * colorArr[1]);
 
             } else if (numHit <= maxHit && numHit == 3) {
             
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[4];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 4; ++i){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[4];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 4; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count <= numHit){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = internalHit;
                         
                     } else if(curHit.geoType == 1){
                         n2 = glassIndex;
                         RayHit rayHitMaxHit3;
                         if(dot(cur_V, curHit.normal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                         }

                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                     }
                     count++;
                 }
                
                 float3 colorArr[4]; 
                 for(int index = 0; index < 4; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[3] += (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz) * n2;

                 for(int k = 0; k < 3; ++k){
                     float3 color = Shade(
                                rayArr[k], 
                                hitArr[k], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] += color; 
                 }   
        
                   
                float3 c3 =  colorArr[3] * (refIndex);
                float3 c2 =  colorArr[2] + (c3 * refIndex);
                float3 c1 =  colorArr[1] + (c2 * refIndex);
                return colorArr[0] + (c1 * refIndex);    
             } else if (numHit <= maxHit && numHit == 4){
                 
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[4];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 4; i++){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[5];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 5; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count <= numHit){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = internalHit;
                         
                     } else if(curHit.geoType == 1){
                         n2 = glassIndex;
                         RayHit rayHitMaxHit3;
                         if(dot(cur_V, curHit.normal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                         }

                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                     }
                     count++;
                 }
                
                 float3 colorArr[5]; 
                 for(int index = 0; index < 5; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[4] += (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz) * n2;
              

                 for(int k = 0; k < 4; ++k){
                     float3 color = Shade(
                                rayArr[k], 
                                hitArr[k], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] += color; 
                 }  
             
                float3 c3 =  colorArr[3] * (refIndex);
                float3 c2 =  colorArr[2] + (c3 * refIndex);
                float3 c1 =  colorArr[1] + (c2 * refIndex);
                return colorArr[0] + (c1 * refIndex); 
                return colorArr[0] + (1.0003/refIndex) * (colorArr[1] + ((1.0003/refIndex) * colorArr[2]));    
             } else {
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[6];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 6; ++i){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[6];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 6; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count < 6){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = internalHit;
                         
                     } else if(curHit.geoType == 1){
                         n2 = glassIndex;
                         RayHit rayHitMaxHit3;
                         if(dot(cur_V, curHit.normal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                         }

                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                     }
                     count++;
                 }
                
                 float3 colorArr[6]; 
                 for(int index = 0; index < 4; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[5] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz) * n2;
              
                 for(int k = 0; k < 5; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                          fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] = color;    
                 }  
                 float3 c5 = colorArr[5]; // skybox
                 float3 c4 = (colorArr[4] *(1 - tranparency)) + (c5 * tranparency);
                 float3 c3 = (colorArr[3] *(1 - tranparency)) + (c4 * tranparency);
                 float3 c2 = (colorArr[2] *(1 - tranparency)) + (c3 * tranparency);
                 float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 return (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
             }
          
    } else {
    
            // if not a geometry, it must be a skybox
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;   
    }
}

#endif // TRANSPARENT_COMPUTE
