#ifndef TRANSPARENT_COMPUTE
#define TRANSPARENT_COMPUTE
#include "SphereInternalIntersect.compute"
#include "RTSphere.compute"
#include "RefractRay.compute"

float3 Transparent(
    int maxHit,
    float3 result,
    inout Ray ray, 
    RayHit hit, 
    float3 ambientLightUpper,
    float3 ambientLightLower,
    int numOfDirLight,
    StructuredBuffer<RTDirectionalLight> dirLights,
    int numOfPointLight,
    StructuredBuffer<RTPointLight> pointLights,
    int numOfSpotLight,
    StructuredBuffer<RTSpotLight> spotLights,
    Texture2D<float4> skybox, 
    SamplerState skyboxSampler,
    int numOfSpheres,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles,
    Texture2DArray<float4> shadowMap,
    StructuredBuffer<RTSpotLight_UW> shadowUtility,
    float fogFactor,
    float3 fogColor,
    int numOfMaterials,
    StructuredBuffer<RTMaterial> materials)
{
    if (hit.distance < 1.#INF)
    {                
             int maxRefractHit = 6; // hardcode

             // hardcode
             float refIndex = 1.52; // glass
             float air_refIndex = 1.0003;
             float triAngleRefractiveIndex = 1.52;
             
             // hard code
             float tranparency = 0.8f;
             
             float diamondIndex = 2.42;
             float crystalIndex = 2.42;
              //float crystalIndex = 1.54259;
             float glassIndex = 1.52;
                   
             int numHit = 0;
             Ray curRay = ray;

             RayHit curHit = hit;;
             float n1 = air_refIndex;
             float n2 = air_refIndex;
             float3 cur_V = -normalize(curRay.direction);
             
             Ray outRay;
             RayHit transRayHit = CreateRayHit();
             while(numHit <= maxRefractHit && curHit.distance < 1.#INF) {
                 //SphereInternalIntersect(RayHit curHit, Ray refrectRay, int numOfSphere,  StructuredBuffer<RTSphere> spheres, int targetId)
                 if(curHit.geoType == 0){ // sphere
                     n2 = crystalIndex;
                     Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                     RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                     cur_V = -normalize(refract.direction);
                     curRay = RefractRay(internalHit, cur_V, -internalHit.normal, n2, n1);
                     curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, 0);  
                     numHit++;
                 } else if(curHit.geoType == 1){ // Triangle
                     n2 = glassIndex;              
                     // Compute the out ray
                     if(dot(cur_V, curHit.normal) > 0 ){               
                         curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                     } else { // must be a sphere                              
                         curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                     }
                     curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);       
                 } 
                 cur_V = -normalize(curRay.direction);   
                 n1 = n2;
                 numHit++;
             }
             
             if(numHit == 1 && numHit <= maxHit) {
                 float3 color =     Shade(
                                    ray, 
                                    hit, 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                          fogColor,
                                numOfMaterials,
                                materials);
                    
                float theta = acos(curRay.direction.y) / -PI;
                float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                return (color * (1 - tranparency))  + (tranparency)*skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz; 
                //return float3(.8, .1, .1);
             } else if(numHit ==  2 && numHit <= maxHit) {
             
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;

                cur_V = -normalize(curRay.direction);
                
                Ray rayArr[3];
                for(int i = 0; i < 3; ++i){
                   rayArr[i] = CreateRay(hit.position, ray.direction);
                }
                     
                RayHit hitArr[3];
                hitArr[0] = hit;
                for(int j = 1; j < 3; ++j){
                   hitArr[j] = CreateRayHit();
                }
                
                // if a sphere
                if(curHit.geoType == 0){
                     
                     n2 = crystalIndex;             
                     int count = 1;
                      
                     // first iteration  
                     Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                     rayArr[count] = refract;
                     RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                     hitArr[count] = internalHit;
                         
                     // second iteration
                     count++;
                     curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                     rayArr[count] = curRay;
                     curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     hitArr[count] = internalHit;
                         
                     float3 colorArr[3]; // numHit + 1
                     for(int m = 0; m < 2; ++m){
                         colorArr[m] = float3(0, 0, 0);
                     }
                     
                     float theta_ph2 = acos(curRay.direction.y) / -PI;
                     float phi_ph2 = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                     colorArr[2] = (skybox.SampleLevel(skyboxSampler, float2(phi_ph2, theta_ph2), 0).xyz);
                     
                     for(int ph2 = 0; ph2 < 2; ++ph2){
                         float3 color = Shade(
                                        rayArr[ph2], 
                                        hitArr[ph2], 
                                        ambientLightUpper,
                                        ambientLightLower,
                                        numOfDirLight,
                                        dirLights,
                                        numOfPointLight,
                                        pointLights,
                                        numOfSpotLight, 
                                        spotLights,
                                        skybox, 
                                        skyboxSampler,
                                        numOfSpheres,
                                        spheres,
                                        numOfTriangle,
                                        triangles,
                                        shadowMap,
                                        shadowUtility,
                                        fogFactor,
                          fogColor,
                                numOfMaterials,
                                materials);
                         colorArr[ph2] = color;    
                     } 
                                      
                     float3 c2 = colorArr[2]* tranparency;
                     float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                     float3 c0 = (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
                     return c0;
                     //return float3(.8, .2, .2);             
                } else { // two triangle 
                
                     n1 = air_refIndex;
                     n2 = glassIndex;

                     int count = 1;
                     RayHit rayHitMaxHit2;
                     while(count <= numHit) {
              
                         // Compute the out ray
                         if(dot(cur_V, curHit.normal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                         }

                         rayHitMaxHit2 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit2;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                         count++;
                     }
                 
                     float3 colorArr[3]; // numHit + 1
                     for(int m = 0; m < 2; ++m){
                         colorArr[m] = float3(0, 0, 0);
                     }
                     
                     float theta = acos(curRay.direction.y) / -PI;
                     float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                     colorArr[2] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);
                  
                     for(int ph2 = 0; ph2 < 2; ++ph2){
                         float3 color = Shade(
                                        rayArr[ph2], 
                                        hitArr[ph2], 
                                        ambientLightUpper,
                                        ambientLightLower,
                                        numOfDirLight,
                                        dirLights,
                                        numOfPointLight,
                                        pointLights,
                                        numOfSpotLight, 
                                        spotLights,
                                        skybox, 
                                        skyboxSampler,
                                        numOfSpheres,
                                        spheres,
                                        numOfTriangle,
                                        triangles,
                                        shadowMap,
                                        shadowUtility,
                                        fogFactor,
                          fogColor,
                                numOfMaterials,
                                materials);
                         colorArr[ph2] = color;    
                     }  
                     float3 c2 = colorArr[2]; // skybox
                     float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                     float3 c0 = (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
                     return c0;
                 }
                 //return float3(0, .8, 0);
             } else if(numHit == 3 && numHit <= maxHit) {
   
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[4];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 4; ++i){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[4];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 4; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count <= numHit){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = internalHit;
                         
                     } else if(curHit.geoType == 1){
                         n2 = glassIndex;
                         RayHit rayHitMaxHit3;
                         if(dot(cur_V, curHit.normal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                         }

                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                     }
                     count++;
                 }
                
                 float3 colorArr[4]; 
                 for(int index = 0; index < 3; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[3] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz) * n2;
              
                 for(int k = 0; k < 3; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                          fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] = color;    
                 }  
                 float3 c1 = colorArr[3]; // skybox
                 float3 c2 = (colorArr[2] *(1 - tranparency)) + (c1 * tranparency);
                 float3 c3 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 return (colorArr[0] *(1 - tranparency)) + (c3 * tranparency);
             } else if(numHit == 4 && numHit <= maxHit) {
              
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[5];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 5; ++i){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[5];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 5; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count <= numHit){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = internalHit;
                         
                     } else if(curHit.geoType == 1){
                         n2 = glassIndex;
                         RayHit rayHitMaxHit3;
                         if(dot(cur_V, curHit.normal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                         }

                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                     }
                     count++;
                 }
                
                 float3 colorArr[5]; 
                 for(int index = 0; index < 3; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[4] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz) * n2;
              
                 for(int k = 0; k < 4; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                          fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] = color;    
                 }  
                 float3 c1 = colorArr[4]; // skybox
                 float3 c2 = (colorArr[3] *(1 - tranparency)) + (c1 * tranparency);
                 float3 c3 = (colorArr[2] *(1 - tranparency)) + (c2 * tranparency);
                 float3 c4 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 return (colorArr[0] *(1 - tranparency)) + (c3 * tranparency);
             } else {
                curRay = ray;
                curHit = hit;
                n1 = air_refIndex;
                n2 = air_refIndex;
                cur_V = -normalize(curRay.direction);
                
                 Ray rayArr[6];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 for(int i = 1; i < 6; ++i){
                     rayArr[i] = CreateRay(hit.position, curRay.direction);
                 }
                 
                 RayHit hitArr[6];
                 hitArr[0] = curHit;
                 for(int j = 1; j < 6; ++j){
                     hitArr[j] = CreateRayHit();
                 }
                 
                 int count = 1;
                 while(count <= numHit){
                     
                     if(curHit.geoType == 0){
                         n2 = crystalIndex;            
                      
                         // first iteration  
                         Ray refract = RefractRay(curHit, cur_V, -normalize(curHit.normal), n1, n2);
                         rayArr[count] = refract;
                         RayHit internalHit = SphereInternalIntersect(curHit, refract, numOfSpheres, spheres, curHit.geoIndex);
                         hitArr[count] = internalHit;
                             
                         // second iteration
                         count++;
                         curRay = RefractRay(internalHit, -normalize(refract.direction), normalize(internalHit.normal), n2, n1);
                         rayArr[count] = curRay;
                         curHit = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         hitArr[count] = internalHit;
                         
                     } else if(curHit.geoType == 1){
                         n2 = glassIndex;
                         RayHit rayHitMaxHit3;
                         if(dot(cur_V, curHit.normal) > 0 ){               
                             curRay = RefractRay(curHit, cur_V, hit.normal, n1, n2);// hit from the back
                         } else { // must be a sphere                              
                             curRay = RefractRay(curHit, cur_V, -hit.normal, n1, n2);// hit from the front
                         }

                         rayHitMaxHit3 = Trace(curRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                         cur_V = -normalize(curRay.direction);
                         curHit = rayHitMaxHit3;
                         rayArr[count] = curRay;
                         hitArr[count] = curHit;  
                     }
                     count++;
                 }
                
                 float3 colorArr[6]; 
                 for(int index = 0; index < 4; ++index){
                     colorArr[index] = float3(0, 0, 0);
                 }
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 colorArr[5] = (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz) * n2;
              
                 for(int k = 0; k < 5; ++k){
                     float3 color = Shade(
                                    rayArr[k], 
                                    hitArr[k], 
                                    ambientLightUpper,
                                    ambientLightLower,
                                    numOfDirLight,
                                    dirLights,
                                    numOfPointLight,
                                    pointLights,
                                    numOfSpotLight, 
                                    spotLights,
                                    skybox, 
                                    skyboxSampler,
                                    numOfSpheres,
                                    spheres,
                                    numOfTriangle,
                                    triangles,
                                    shadowMap,
                                    shadowUtility,
                                    fogFactor,
                          fogColor,
                                numOfMaterials,
                                materials);
                     colorArr[k] = color;    
                 }  
                 float3 c5 = colorArr[5]; // skybox
                 float3 c4 = (colorArr[4] *(1 - tranparency)) + (c5 * tranparency);
                 float3 c3 = (colorArr[3] *(1 - tranparency)) + (c4 * tranparency);
                 float3 c2 = (colorArr[2] *(1 - tranparency)) + (c3 * tranparency);
                 float3 c1 = (colorArr[1] *(1 - tranparency)) + (c2 * tranparency);
                 return (colorArr[0] *(1 - tranparency)) + (c1 * tranparency);
             }
          
    } else {
    
            // if not a geometry, it must be a skybox
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;   
    }
}

#endif // TRANSPARENT_COMPUTE