#include "../Ray.compute"
#include "../RayHit.compute"
#include "../RTSphere.compute"
#include "../RayCasting/Trace.compute"

float3 Transparent(
    int maxHit,
    float3 result,
    inout Ray ray, 
    RayHit hit, 
    float3 ambientLightUpper,
    float3 ambientLightLower,
    int numOfDirLight,
    StructuredBuffer<RTDirectionalLight> dirLights,
    int numOfPointLight,
    StructuredBuffer<RTPointLight> pointLights,
    int numOfSpotLight,
    StructuredBuffer<RTSpotLight> spotLights,
    Texture2D<float4> skybox, 
    SamplerState skyboxSampler,
    int numOfSpheres,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles,
    Texture2DArray<float4> shadowMap,
    StructuredBuffer<RTSpotLight_UW> shadowUtility,
    float fogFactor,
    float3 fogColor)
{
    if (hit.distance < 1.#INF)
    {         
         Ray curRay = ray;
         RayHit curHit = hit;
             
         float3 V = -normalize(curRay.direction);//int numHit = 1;
         
         if(hit.geoType == 0){   
             // hardcode
             float refIndex = 1.52; // glass
             float air_refIndex = 1.0003;
               
             float3 useNormal_raw = -curHit.normal;
             float3 useNormal = normalize(useNormal_raw);
             float cosThetaI = dot(V, useNormal);
             float invN = air_refIndex/ refIndex;
             float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
             float3 transDir = -((invN * V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
             
             Ray transRay = CreateRay(curHit.position, -transDir);
             curRay = transRay;
             float3 cur_V = -normalize(curRay.direction);
             
             // check if hit anything else
             RayHit transRayHit = Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
             
             curHit = transRayHit;  
             
             int numHit = 1;     
              
             if(numHit == 1){    
                                                                                          
                float theta = acos(curRay.direction.y) / -PI;
                float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
             } else {
                return float3(0, 0, 0);
             } 
             
         } else { // if triangles
            
             // hardcode
             float refIndex = 1.52; // glass
             float air_refIndex = 1.0003;
               
             // triangle only
             float3 useNormal_raw = -triangles[0].normal;
             float3 useNormal = normalize(useNormal_raw);
             float cosThetaI = dot(V, useNormal);
             float invN = air_refIndex/ refIndex;
             float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
             float3 transDir = -((invN * V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
             Ray transRay = CreateRay(curHit.position, transDir);
             curRay = transRay;
             float3 cur_V = -normalize(curRay.direction);
             
             // check if hit anything else
             RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
             curHit = transRayHit;
                        
             int numHit = 0;               
             while(numHit <= maxHit && curHit.distance < 1.#INF){
             
                 float3 useNormal_raw = -curHit.normal;
                 float3 useNormal = normalize(useNormal_raw);
                 float cosThetaI = dot(cur_V, useNormal);
                 float invN = air_refIndex/ refIndex;
                 float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
                 float3 transDir = -((invN * cur_V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
                 Ray transRay = CreateRay(curHit.position, -transDir);
                 curRay = transRay;
                 cur_V = -normalize(curRay.direction);
                 
                 RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                 curHit = transRayHit;
                 numHit++;
             }     
              
             if(numHit == 0){
                float theta = acos(curRay.direction.y) / -PI;
                float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                return (skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz);
                
             } else if(numHit == 1){
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[2];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 rayArr[1] = CreateRay(hit.position, curRay.direction);
                 
                 RayHit hitArr[2];
                 hitArr[0] = curHit;
                 hitArr[1] = CreateRayHit();
                           
                 int count = 1;
                            
                     float3 useNormal_raw = -curHit.normal;
                     float3 useNormal = normalize(useNormal_raw);
                     float cosThetaI = dot(cur_V, useNormal);
                     float invN = air_refIndex/ refIndex;
                     float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
                     float3 transDir = -((invN * cur_V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
                     Ray transRay = CreateRay(curHit.position, -transDir);
                     curRay = transRay;
                     rayArr[count] = curRay;
                     cur_V = -normalize(curRay.direction);
                     
                     RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = transRayHit;
                     hitArr[count] = curHit;
  
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 
                 float3 colorArr[2];
                 colorArr[0] = result;//float3(0, 0, 0);
                 colorArr[1] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz; 
                 float3 color = Shade(
                                rayArr[1], 
                                hitArr[1], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor);
                 colorArr[0] += color;
                 return colorArr[0] + ((1.0003/refIndex) * colorArr[1]);
                
             } else if(numHit == 2){
             
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[3];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 rayArr[1] = CreateRay(hit.position, curRay.direction);
                 rayArr[2] = CreateRay(hit.position, curRay.direction);
                 
                 RayHit hitArr[3];
                 hitArr[0] = curHit;
                 hitArr[1] = CreateRayHit();
                 hitArr[2] = CreateRayHit();
                           
                 int count = 1;
                 
                 while(count <= 2){
                               
                     float3 useNormal_raw = -curHit.normal;
                     float3 useNormal = normalize(useNormal_raw);
                     float cosThetaI = dot(cur_V, useNormal);
                     float invN = air_refIndex/ refIndex;
                     float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
                     float3 transDir = -((invN * cur_V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
                     Ray transRay = CreateRay(curHit.position, -transDir);
                     curRay = transRay;
                     rayArr[count] = curRay;
                     cur_V = -normalize(curRay.direction);
                     
                     RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = transRayHit;
                     hitArr[count] = curHit;
                     count++;
                 }   
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 
                 float3 colorArr[3];
                 colorArr[0] = float3(0, 0, 0);
                 colorArr[1] = float3(0, 0, 0);
                 int i = 1;
                 while(i >= 0){
                     float3 color = Shade(
                                rayArr[i], 
                                hitArr[i], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor);
                     colorArr[i] += color; 
                     --i;
                 }               
                 colorArr[2] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;    
                // paint   
                return colorArr[0] + (1.0003/refIndex) * (colorArr[1] + ((1.0003/refIndex) * colorArr[2]));             
             } else if (numHit == 3) {
             
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[4];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 rayArr[1] = CreateRay(hit.position, curRay.direction);
                 rayArr[2] = CreateRay(hit.position, curRay.direction);
                 rayArr[3] = CreateRay(hit.position, curRay.direction);
                 
                 RayHit hitArr[4];
                 hitArr[0] = curHit;
                 hitArr[1] = CreateRayHit();
                 hitArr[2] = CreateRayHit();
                 hitArr[3] = CreateRayHit();
                           
                 int count = 1;
                 
                 while(count <= 3){
                               
                     float3 useNormal_raw = -curHit.normal;
                     float3 useNormal = normalize(useNormal_raw);
                     float cosThetaI = dot(cur_V, useNormal);
                     float invN = air_refIndex/ refIndex;
                     float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
                     float3 transDir = -((invN * cur_V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
                     Ray transRay = CreateRay(curHit.position, -transDir);
                     curRay = transRay;
                     rayArr[count] = curRay;
                     cur_V = -normalize(curRay.direction);
                     
                     RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = transRayHit;
                     hitArr[count] = curHit;
                     count++;
                 }   
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 
                 float3 colorArr[4];
                 colorArr[0] = float3(0, 0, 0);
                 colorArr[1] = float3(0, 0, 0);
                 colorArr[2] = float3(0, 0, 0);
                 colorArr[3] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;  
                 
                 int i = 2;
                 while(i >= 0){
                     float3 color = Shade(
                                rayArr[i], 
                                hitArr[i], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor);
                     colorArr[i] += color; 
                     --i;
                 }               
                   
                float3 c3 =  colorArr[3] * (refIndex);
                float3 c2 =  colorArr[2] + (c3 * refIndex);
                float3 c1 =  colorArr[1] + (c2 * refIndex);
                return colorArr[0] + (c1 * refIndex);    
             } else if (numHit == 4){
                 
                 curRay = ray;
                 curHit = hit;
             
                 Ray rayArr[4];
                 rayArr[0] = CreateRay(curHit.position, curRay.direction);
                 rayArr[1] = CreateRay(hit.position, curRay.direction);
                 rayArr[2] = CreateRay(hit.position, curRay.direction);
                 rayArr[3] = CreateRay(hit.position, curRay.direction);
                 
                 RayHit hitArr[4];
                 hitArr[0] = curHit;
                 hitArr[1] = CreateRayHit();
                 hitArr[2] = CreateRayHit();
                 hitArr[3] = CreateRayHit();
                           
                 int count = 1;
                 
                 while(count <= 3){
                               
                     float3 useNormal_raw = -curHit.normal;
                     float3 useNormal = normalize(useNormal_raw);
                     float cosThetaI = dot(cur_V, useNormal);
                     float invN = air_refIndex/ refIndex;
                     float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
                     float3 transDir = -((invN * cur_V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
                     Ray transRay = CreateRay(curHit.position, -transDir);
                     curRay = transRay;
                     rayArr[count] = curRay;
                     cur_V = -normalize(curRay.direction);
                     
                     RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = transRayHit;
                     hitArr[count] = curHit;
                     count++;
                 }   
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 
                 float3 colorArr[4];
                 colorArr[0] = float3(0, 0, 0);
                 colorArr[1] = float3(0, 0, 0);
                 colorArr[2] = float3(0, 0, 0);
                 colorArr[3] = skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;  
                 int i = 2;
                 while(i >= 0){
                     float3 color = Shade(
                                rayArr[i], 
                                hitArr[i], 
                                ambientLightUpper,
                                ambientLightLower,
                                numOfDirLight,
                                dirLights,
                                numOfPointLight,
                                pointLights,
                                numOfSpotLight, 
                                spotLights,
                                skybox, 
                                skyboxSampler,
                                numOfSpheres,
                                spheres,
                                numOfTriangle,
                                triangles,
                                shadowMap,
                                shadowUtility,
                                fogFactor,
                                fogColor);
                     colorArr[i] += color; 
                     --i;
                 }               
                float3 c3 =  colorArr[3] * (refIndex);
                float3 c2 =  colorArr[2] + (c3 * refIndex);
                float3 c1 =  colorArr[1] + (c2 * refIndex);
                return colorArr[0] + (c1 * refIndex); 
                return colorArr[0] + (1.0003/refIndex) * (colorArr[1] + ((1.0003/refIndex) * colorArr[2]));    
             } else {
                 curRay = ray;
                 curHit = hit;

                 int numHit = 0;               
                 while(numHit <= maxHit && curHit.distance < 1.#INF){
                 
                     float3 useNormal_raw = -curHit.normal;
                     float3 useNormal = normalize(useNormal_raw);
                     float cosThetaI = dot(cur_V, useNormal);
                     float invN = air_refIndex/ refIndex;
                     float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
                     float3 transDir = -((invN * cur_V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
                     Ray transRay = CreateRay(curHit.position, -transDir);
                     curRay = transRay;
                     cur_V = -normalize(curRay.direction);
                     
                     RayHit transRayHit= Trace(transRay, numOfSpheres, spheres,  numOfTriangle, triangles, curHit.geoIndex);
                     curHit = transRayHit;
                     numHit++;
                 }   
                 
                 float theta = acos(curRay.direction.y) / -PI;
                 float phi = atan2(curRay.direction.x, -curRay.direction.z) / -PI * 0.5f;
                 return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
             }
         }
                
    } else {
    
            // if not a geometry, it must be a skybox
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;   
    }
}