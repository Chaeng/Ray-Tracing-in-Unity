#include "../Ray.compute"
#include "../RayHit.compute"
#include "../RTSphere.compute"
#include "../RayCasting/Trace.compute"

float3 Transparent(
    float3 result,
    inout Ray ray, 
    RayHit hit, 
    float3 ambientLightUpper,
    float3 ambientLightLower,
    int numOfDirLight,
    StructuredBuffer<RTDirectionalLight> dirLights,
    int numOfPointLight,
    StructuredBuffer<RTPointLight> pointLights,
    int numOfSpotLight,
    StructuredBuffer<RTSpotLight> spotLights,
    Texture2D<float4> skybox, 
    SamplerState skyboxSampler,
    int numOfSpheres,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles,
    Texture2DArray<float4> shadowMap,
    StructuredBuffer<RTSpotLight_UW> shadowUtility)
{

    if (hit.distance < 1.#INF)
    {   
         int numHit = 1;
         Ray curRay = ray;
         RayHit curHit = hit;
         
         float3 V = -normalize(curRay.direction);
         
         // hardcode
         float refIndex = 1.52; // glass
         float air_refIndex = 1.0003;
         // hardcode
         
         /*
         // triangle only
         
         float3 useNormal_raw = triangles[0].normal;
         float3 useNormal = normalize(useNormal_raw);
         float cosThetaI = dot(V, useNormal);
         float invN = 1/ refIndex;
         float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
         float3 transDir = -((invN * V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
         Ray transRay = CreateRay(curHit.position, transDir);
         float3 rayNor = normalize(transRay.direction);
         RayHit newHit = CreateRayHit();
         IntersectTriangle(transRay, newHit, triangles[0], 0);
         float3 triangleColor = Shade(
                        transRay, 
                        newHit, 
                        ambientColor,
                        numOfDirLight,
                        dirLights,
                        numOfPointLight,
                        pointLights,
                        numOfSpotLight, 
                        spotLights,
                        skybox, 
                        skyboxSampler,
                        numOfSpheres,
                        spheres,
                        numOfTriangle,
                        triangles,
                        shadowMap,
                        shadowUtility); 

         if(numHit > 0)
         {
             float theta = acos(transRay.direction.y) / -PI;
             float phi = atan2(transRay.direction.x, -transRay.direction.z) / -PI * 0.5f;
             return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz; 
         }
         
         */
       
         float3 useNormal_raw = -hit.normal;
         float3 useNormal = normalize(useNormal_raw);
         float cosThetaI = dot(V, useNormal);
         float invN = 1/ air_refIndex;
         float cosThetaT = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
         float3 transDir = -((invN * V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
         
         Ray transRay = CreateRay(curHit.position, transDir);                
         RayHit newHit;
         
         for(int i = 0; i < numOfSpheres; ++i){
            newHit = Trace(transRay, numOfSpheres, spheres, numOfTriangle, triangles, i);
         }
         /*
         float3 V = -normalize(transRay.direction);
         float3 useNormal_raw2 = -newHit.normal;
         float3 useNormal2 = normalize(useNormal_raw);
         float cosThetaI2 = dot(V, useNormal);
         float invN2 = 1/ refIndex;
         float cosThetaT2 = sqrt( 1 - ((invN * invN) * (1 - (cosThetaI * cosThetaI))));
         float3 transDir2 = -((invN * V) + ((cosThetaT - (invN * cosThetaI)) * useNormal));
               */          
         Ray transRay2 = CreateRay(newHit.position, transDir);
         RayHit newHit2 = Trace(transRay2, numOfSpheres, spheres, numOfTriangle, triangles, 0);
         float3 reflecColor = Shade(
                        transRay2, 
                        newHit2, 
                        ambientLightUpper,
                        ambientLightLower,
                        numOfDirLight,
                        dirLights,
                        numOfPointLight,
                        pointLights,
                        numOfSpotLight, 
                        spotLights,
                        skybox, 
                        skyboxSampler,
                        numOfSpheres,
                        spheres,
                        numOfTriangle,
                        triangles,
                        shadowMap,
                        shadowUtility); 
          return   reflecColor;        
                  /*      
                  float3 triangleColor2 = Shade(
                        transRay2, 
                        newHit2, 
                        ambientColor,
                        numOfDirLight,
                        dirLights,
                        numOfPointLight,
                        pointLights,
                        numOfSpotLight, 
                        spotLights,
                        skybox, 
                        skyboxSampler,
                        numOfSpheres,
                        spheres,
                        numOfTriangle,
                        triangles,
                        shadowMap,
                        shadowUtility); */
/*
         if(numHit > 0)
         {
             float theta = acos(transRay2.direction.y) / -PI;
             float phi = atan2(transRay2.direction.x, -transRay2.direction.z) / -PI * 0.5f;
             return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz; 
         }*/
        
    } else {
    
            // if not a geometry, it must be a skybox
            float theta = acos(ray.direction.y) / -PI;
            float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
            return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;   
    }
}