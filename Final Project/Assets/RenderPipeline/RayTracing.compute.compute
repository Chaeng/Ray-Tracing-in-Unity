#include "Ray.compute"
#include "RayHit.compute"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

//Skybox
Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;
static const float PI = 3.14159265f;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;


Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    return CreateRay(origin, direction);
}

void IntersectSphere(Ray ray, inout RayHit bestHit, float4 sphere)
{
    // The ray equation in from of (ray.origin) + (distance travelled, d) * (ray.direction) = (the contact point)   Equ(1)
    // The sphere equation in form of [|(contact point) - (center; sphere.xyz)|]^2 = (radius; sphere.w)^2.0f          Equ(2)

    // Step 1: Define
    // float3 oriToCtr = sphere.xyz - ray.origin;    
    // float d = dot(ray.direction, oriToCtr); // Vector projection to get initial distance travelled

    // Equ(1) --> Equ(2)
    // [|(ray.origin) + (d)*(ray.direction)- (sphere.xyz)|]^2 - (sphere.w)^2 = 0
    // (ray.direction)^2*(d)^2 + 2(ray.direction)*(ray.origin-sphere.xyz)*(d) + (ray.origin-sphere.xyz)^2  - (sphere.w)^2 = 0.0f    Equ(3)

    // Step 2: Discriminant
    // We calculate discriminant to determine whether there is real roots, thus, intersection
    // Check delta: b^2 - 4ac
    // [2(ray.origin-sphere.xyz)*(ray.direction)]^2 - 4((ray.direction)^2)*((ray.origin - sphere.xyz)^2 - (sphere.w)^2)   Equ(4)
    //
    // Since (ray.direction) is a unit vector, (ray.direction)^2 = 1.0f     Equ(5)
    // Equ(5) --> Equ(4)
    //
    // 4[(ray.origin-sphere.xyz)*(ray.direction)]^2 - 4((ray.origin - sphere.xyz)^2 - (sphere.w)^2)
    // 4*dot(ray.direction, -oriToCtr)^2 - 4*dot(-oriToCtr, -oriToCtr)^2 + 4*(sphere.w)^2
    // d * d - dot(oriToCtr, oriToCtr) + (sphere.w) * (sphere.w)    Note that the 4 is obmitted as it is taken out
    //
    // If discriminant < 0, then there is no intersection
    //

    // Step 3: Calculate hit distance
    // If there is intersection(s), we calculate the actual distance travelled by solving d
    // d = [-b +/- sqrt(b^2-4ac)] / 2a
    //
    // From Equ(5), we know that 2a = 2 * (ray.direction) ^ 2 = 2
    //
    // hitDis = -(ray.direction * (ray.origin - sphere.xyz)) +/- disSqrt
    // hitDis = -dot(ray.direction, -oriToCtr) +/- disSqrt
    // hitDis = d +/- disSqrt
    //
    // Because hitDis cannot be negative, and we want the closest hit, so we take the least positive value of d +/- disSqrt

    // Step 4: Update best hit distance
    //

    // // Step 1: Define
    float3 oriToCtr = sphere.xyz - ray.origin;
    float d = dot(ray.direction, oriToCtr);

    // Step 2: Discriminant
    float discriminant = d * d - dot(-oriToCtr, -oriToCtr) + sphere.w * sphere.w;
    if(discriminant < 0)
    {
        return;
    }

    // Step 3: Calculate hit distance
    float disSqrt = sqrt(discriminant);
    float hitDis = d - disSqrt > 0 ? d - disSqrt : d + disSqrt;     // If d - disSqrt > 0, then d + disSqrt must be greater than d - disSqrt, we take the least positive value; Otherwise, we take d + disSqrt

    // Step 4: Update best hit distance
    if (hitDis > 0 && hitDis < bestHit.distance)
    {
        bestHit.distance = hitDis;
        bestHit.position = ray.origin + hitDis * ray.direction;
        bestHit.normal = normalize(bestHit.position - sphere.xyz);
    }
}

RayHit Trace(Ray ray)
{
    RayHit bestHit = CreateRayHit();
    // Add a floating unit sphere
       IntersectSphere(ray, bestHit, float4(0, 3.0f, 0, 1.0f));
    return bestHit;
}

float3 Shade(inout Ray ray, RayHit hit)
{
    if (hit.distance < 1.#INF)
    {
        // Return the normal
        return hit.normal * 0.5f + 0.5f;
    }
    else
    {
        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);
    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);

    
    // Sample the skybox and write it
    float theta = acos(ray.direction.y) / -PI;
    float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
    
    // Trace and shade
    RayHit hit = Trace(ray);
    float3 result = Shade(ray, hit);
    Result[id.xy] = float4(result, 1);
}






