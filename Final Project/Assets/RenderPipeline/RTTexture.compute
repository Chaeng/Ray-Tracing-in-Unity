#ifndef RTTEXTURE_COMPUTE
#define RTTEXTURE_COMPUTE


struct RTTexture
{
    int id;

    // support for image
    int isColor;
    int imageIndex;

    // support for checker pattern
    int isChecker;
    int uRepeat;
    int vRepeat;
    float3 color1;
    float3 color2;
};

RTTriangle mTri;
RTTexture mTex1;
int TextureImageSize = 64;    // TODO: Get this dimension from Utility

RTSphere mSph;
RTTexture mTex2;

RTTexture GetDefaultTexture()
{
    RTTexture tex;

    tex.id = -1;

    // support for image
    tex.isColor = 0;
    tex.imageIndex = -1;

    // support for checker pattern
    tex.isChecker = 0;
    tex.uRepeat = 0;
    tex.vRepeat = 0;
    tex.color1 = float3(0, 0, 0);
    tex.color2 = float3(0, 0, 0);

    return tex;
}

RTTexture GetIndexedTexture(StructuredBuffer<RTTexture> textures,
    int numOfTextures,
    int index)
{
    RTTexture tex;

    // If index valid, then retrieve texture
    if (index >= 0 && index < numOfTextures)
    {
        tex = textures[index];
    }
    // Otherwise, return default texture
    else
    {
        tex = GetDefaultTexture();
    }

    return tex;
}

void InitUv_Triangle(RTTriangle tri, RTTexture tex)
{
    mTri = tri;
    mTex1 = tex;
}

void CalcUvCoords_Triangle(float3 pt,
    float3 bc,
    inout float u,
    inout float v)
{
    u = bc.x * mTri.verticesUV[0].x + bc.y * mTri.verticesUV[1].x
        + bc.z * mTri.verticesUV[2].x;
    v = bc.x * mTri.verticesUV[0].y + bc.y * mTri.verticesUV[1].y
        + bc.z * mTri.verticesUV[2].y;
}

float3 GetUvTexile_Triangle_Color(float u,
    float v,
    RayHit hit,
    Texture2DArray<float4> textureImages)
{
    int i = (int) (u * TextureImageSize);
    int j = (int) (v * TextureImageSize);
    uint3 id = uint3(i, j, mTex1.imageIndex);
    float4 map = textureImages[id.xyz];
    return map.xyz;
}

float3 GetUvTexile_Triangle_Checker(float u,
    float v,
    RayHit hit)
{
    if((uint)(u * mTex1.uRepeat) % 2 == (uint)(v * mTex1.vRepeat) % 2)
    {
        return mTex1.color1;
    }
    else
    {
        return mTex1.color2;
    }
}

float3 GetTexturedAttr_Triangle(RTTexture tex,
    RayHit hit,
    RTTriangle tri,
    Texture2DArray<float4> textureImages)
{
    float u, v;
    InitUv_Triangle(tri, tex);
    CalcUvCoords_Triangle(hit.position, hit.barycentric, u, v);
    if (tex.isColor)
    {
    return float3(0, 0, 0); // TODO: Remove -- TROUBLESHOOT HERE ... WHY IS IMG NOT SHOWING UP
        return GetUvTexile_Triangle_Color(u, v, hit, textureImages);
    }
    else if (tex.isChecker)
    {
        return GetUvTexile_Triangle_Checker(u, v, hit);
    }
    else
    {
        float3 defaultTexile = float3(1, 1, 1);
        return defaultTexile;
    }
}

void InitUv_Sphere(RTSphere sph, RTTexture tex)
{
    mSph = sph;
    mTex2 = tex;
}

void CalcUvCoords_Sphere(float3 pt,
    float3 bc,
    inout float u,
    inout float v)
{
    float _PI = 3.14159265f;
    float3 N = normalize(pt - mSph.center);
    u = 0.5 + atan2(N.x, N.z) / (2 * _PI);
    v = 0.5 - asin(N.y) / _PI;
}

float3 GetUvTexile_Sphere_Color(float u,
    float v,
    RayHit hit,
    Texture2DArray<float4> textureImages)
{
    int i = (int) (u * TextureImageSize);
    int j = (int) (v * TextureImageSize);
    uint3 id = uint3(i, j, mTex2.imageIndex);
    float4 map = textureImages[id.xyz];
    return map.xyz;
}

float3 GetUvTexile_Sphere_Checker(float u,
    float v,
    RayHit hit)
{
    if((uint)(u * mTex2.uRepeat) % 2 == (uint)(v * mTex2.vRepeat) % 2)
    {
        return mTex2.color1;
    }
    else
    {
        return mTex2.color2;
    }
}

float3 GetTexturedAttr_Sphere(RTTexture tex,
    RayHit hit,
    RTSphere sph,
    Texture2DArray<float4> textureImages)
{
    float u, v;
    InitUv_Sphere(sph, tex);
    CalcUvCoords_Sphere(hit.position, hit.barycentric, u, v);
    if (tex.isColor)
    {
        return GetUvTexile_Sphere_Color(u, v, hit, textureImages);
    }
    else if (tex.isChecker)
    {
        return GetUvTexile_Sphere_Checker(u, v, hit);
    }
    else
    {
        float3 defaultTexile = float3(1, 1, 1);
        return defaultTexile;
    }
}

#endif // RTTEXTURE_COMPUTE
