#ifndef SPATIAL_GRID_TRACE_COMPUTE
#define SPATIAL_GRID_TRACE_COMPUTE

#include "../Ray.compute"
#include "../RayHit.compute"
#include "RayBoxIntersection.compute"
#include "SpatialGrid.compute"
#include "../Geometry/RTTriangle.compute"


GridStep DetermineGridStep(Ray ray)
{
    GridStep step;
    
    step.x = ray.direction.x >= 0 ? 1 : -1;
    step.y = ray.direction.y >= 0 ? 1 : -1;
    step.z = ray.direction.z >= 0 ? 1 : -1;
    
    return step;
};


void GetNumberOfGeometryInGrid(SpatialGridIndex index, StructuredBuffer<int> geomGridList, int dimension, inout int start, inout int count)
{
    int i = index.z + index.y * dimension + index.x * dimension * dimension;
    start = geomGridList[i];
    count = geomGridList[i + 1] - geomGridList[i];   // The index is offset by 1 due to leading zero field
};


RayHit LocalGridTrace(Ray ray, SpatialGridIndex index, StructuredBuffer<int> geomGridList, StructuredBuffer<RTTriangle> triangles, SpatialGrid grids, int excludeGeometry)
{
    RayHit bestHit = CreateRayHit();
    RayHit currentHit = CreateRayHit();

    int start = 0;
    int count = 0;
    
    GetNumberOfGeometryInGrid(index, geomGridList, grids.dimension, start, count);
    
    if(count == 0)
    {
        return bestHit;
    }
    
    float3 localMin = GetGridLocalMin(grids, index);
    float3 localMax = GetGridLocalMax(grids, index);
    
    for(int t = start; t < count; t++)
    {
        if(triangles[t].id == excludeGeometry)
        {
            continue;
        }
        IntersectTriangle(ray, currentHit, triangles[t]);
        /*
        if(!(localMin.x <= currentHit.position.x && currentHit.position.x <= localMax.x))
        {
            currentHit = bestHit;   // Reset currentHit
            continue;
        }
        
        if(!(localMin.y <= currentHit.position.y && currentHit.position.y <= localMax.y))
        {
            currentHit = bestHit;   // Reset currentHit
            continue;
        }
        
        if(!(localMin.z <= currentHit.position.z && currentHit.position.z <= localMax.z))
        {
            currentHit = bestHit;   // Reset currentHit
            continue;
        }
        */
        bestHit = currentHit;
        
    }
    
    return bestHit;
};




RayHit SpatialGridTrace(Ray ray, SpatialGrid spatialGrid, StructuredBuffer<int> geomGridList, StructuredBuffer<RTTriangle> triangles, int excludeGeometry)
{
    RayHit bestHit = CreateRayHit();
    
    float t0 = -1.#INF;
    float t1 = 1.#INF;

    
    if (RayBoxIntersection(ray, spatialGrid.min, spatialGrid.max, t0, t1))
    {
        float3 entry = GetPoint(ray, t1);
        
        GridStep step = DetermineGridStep(ray);
        
        Ray entryToBoundaryRay = CreateRay(entry, ray.direction);
        SpatialGridIndex entryGridIndex = GetGridIndexAtPoint(spatialGrid, entry);
        RayHit deltaX, deltaY, deltaZ;
        GetDeltaToBoundary(
            entryGridIndex, 
            spatialGrid,
            entryToBoundaryRay,
            step,
            deltaX,
            deltaY,
            deltaZ);
        
        RayHit distToNextX, distToNextY, distToNextZ;
        DistanceBetweenBoundary(
            ray, 
            step, 
            entryGridIndex,
            spatialGrid,
            deltaX.position,
            deltaY.position,
            deltaZ.position,
            distToNextX,
            distToNextY,
            distToNextZ
        );
        
        float tx = deltaX.distance;
        float ty = deltaY.distance;
        float tz = deltaZ.distance;
        
        SpatialGridIndex current = entryGridIndex;

        do
        {
            bestHit = LocalGridTrace(
                                    ray,
                                    current,
                                    geomGridList,
                                    triangles,
                                    spatialGrid,
                                    -1);
                                    
            if (tx < ty)
            {
                if (tx < tz)
                {
                    // Move On X
                    current.x = current.x + step.x;
                    tx += distToNextX.distance;
                }
                else
                {
                    // Move On Z
                    current.z = current.z + step.z;
                    tz += distToNextZ.distance;
                }
            }
            else
            {
                if (ty < tz)
                {
                    // Move On Y
                    current.y = current.y + step.y;
                    ty += distToNextY.distance;
                }
                else
                {
                    // Move On Z
                    current.z = current.z + step.z;
                    tz += distToNextZ.distance;
                }
            }
            
        }
        while(!(bestHit.distance < 1.#INF) && !IsGridIndexOutsideGrid(spatialGrid, current));
        
    }
    
    return bestHit;
};

#endif //SPATIALGRIDTRACE_COMPUTE