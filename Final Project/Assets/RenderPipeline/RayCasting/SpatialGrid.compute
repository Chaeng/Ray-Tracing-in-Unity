#ifndef Spatial_Grid_Compute
#define Spatial_Grid_Compute

#include "RayPlaneIntersection.compute"

static const float3 GridNormalLeft = float3(-1, 0, 0);
static const float3 GridNormalRight = float3(1, 0, 0);
static const float3 GridNormalUp = float3(0, 1, 0);
static const float3 GridNormalDown = float3(0, -1, 0);
static const float3 GridNormalBack = float3(0, 0, -1);
static const float3 GridNormalForward = float3(0, 0, 1);

struct SpatialGridIndex
{
    int x;
    int y;
    int z;
};

struct SpatialGrid
{
    float3 min;
    float3 max;
    float dimension;
    
    float w;    // Grid Width
    float h;    // Grid Height
    float d;    // Grid Depth
};

struct GridStep
{
    int x;
    int y;
    int z;
};


SpatialGrid CreateSpatialGrid(float3 min, float3 max, float dimension)
{
    SpatialGrid grids;
    
    grids.min = min;
    grids.max = max;
    grids.dimension = dimension;
    
    grids.w = (grids.max.x - grids.min.x) / dimension;
    grids.h = (grids.max.y - grids.min.y) / dimension;
    grids.d = (grids.max.z - grids.min.z) / dimension;
    
    return grids;
};


SpatialGridIndex GetGridIndexAtPoint(SpatialGrid grid, float3 pt)
{
    int d = grid.dimension;

    SpatialGridIndex index;
    
    index.x = floor((pt.x - grid.min.x) / (grid.max.x - grid.min.x) * d);
    index.x = clamp(index.x, 0, d - 1);
    
    index.y = floor((pt.y - grid.min.y) / (grid.max.y - grid.min.y) * d);
    index.y = clamp(index.y, 0, d - 1);
    
    index.z = floor((pt.z - grid.min.z) / (grid.max.z - grid.min.z) * d);
    index.z = clamp(index.z, 0, d - 1);
    
    return index;
};


bool IsGridIndexOutsideGrid(SpatialGrid grid, SpatialGridIndex index)
{
    return  (index.x >= grid.dimension || index.x < 0) || 
            (index.y >= grid.dimension || index.y < 0) || 
            (index.z >= grid.dimension || index.z < 0);
}


float3 GetGridLocalMin(SpatialGrid grids, SpatialGridIndex index)
{
    float3 localMin = float3(0, 0, 0);
    localMin.x = grids.min.x + grids.w * index.x;
    localMin.y = grids.min.y + grids.h * index.y;
    localMin.z = grids.min.z + grids.d * index.z;
    return localMin;
};

float3 GetGridLocalMax(SpatialGrid grids, SpatialGridIndex index)
{
    float3 localMax = float3(0, 0, 0);
    localMax.x = grids.min.x + grids.w * (index.x + 1);
    localMax.y = grids.min.y + grids.h * (index.y + 1);
    localMax.z = grids.min.z + grids.d * (index.z + 1);
    return localMax;
};


void InnerDistanceToBoundary(Ray ray, GridStep steps, float3 min, float3 max, inout RayHit rayHitX, inout RayHit rayHitY, inout RayHit rayHitZ)
{
    if(steps.x >= 0)
    {
        rayHitX = RayPlaneIntersection(ray, GridNormalLeft, max);
    }
    else
    {
        rayHitX = RayPlaneIntersection(ray, GridNormalRight, min);
    }
    
    if(steps.y >= 0)
    {
        rayHitY = RayPlaneIntersection(ray, GridNormalDown, max);
    }
    else
    {
        rayHitY = RayPlaneIntersection(ray, GridNormalUp, min);
    }
    
    if(steps.z >= 0)
    {
        rayHitZ = RayPlaneIntersection(ray, GridNormalBack, max);
    }
    else
    {
        rayHitZ = RayPlaneIntersection(ray, GridNormalForward, min);
    }
};


void DistanceBetweenBoundary(Ray ray, GridStep steps, SpatialGridIndex entryGridIndex, SpatialGrid grids, float3 firstHitX, float3 firstHitY, float3 firstHitZ, inout RayHit rayHitX, inout RayHit rayHitY, inout RayHit rayHitZ)
{
    float3 min = GetGridLocalMin(grids, entryGridIndex);
    float3 max = GetGridLocalMax(grids, entryGridIndex);

    Ray rX = CreateRay(firstHitX, ray.direction);
    Ray rY = CreateRay(firstHitY, ray.direction);
    Ray rZ = CreateRay(firstHitZ, ray.direction);
    
    if(steps.x >= 0)
    {
        rayHitX = RayPlaneIntersection(rX, GridNormalLeft, max + GridNormalRight);
    }
    else
    {
        rayHitX = RayPlaneIntersection(rX, GridNormalRight, min + GridNormalLeft);
    }
    
    if(steps.y >= 0)
    {
        rayHitY = RayPlaneIntersection(rY, GridNormalDown, max + GridNormalUp);
    }
    else
    {
        rayHitY = RayPlaneIntersection(rY, GridNormalUp, min + GridNormalDown);
    }
    
    if(steps.z >= 0)
    {
        rayHitZ = RayPlaneIntersection(rZ, GridNormalBack, max + GridNormalForward);
    }
    else
    {
        rayHitZ = RayPlaneIntersection(rZ, GridNormalForward, min + GridNormalBack);
    }
};



void GetDeltaToBoundary(SpatialGridIndex entryGridIndex, SpatialGrid grids, Ray entryToBoundaryRay, GridStep steps, inout RayHit rayHitX, inout RayHit rayHitY, inout RayHit rayHitZ)
{
    InnerDistanceToBoundary(
        entryToBoundaryRay, 
        steps, 
        GetGridLocalMin(grids, entryGridIndex),
        GetGridLocalMax(grids, entryGridIndex),
        rayHitX,
        rayHitY,
        rayHitZ);
};


#endif  // Spatial_Grid_Compute