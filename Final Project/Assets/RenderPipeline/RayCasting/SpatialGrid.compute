#ifndef Spatial_Grid_Compute
#define Spatial_Grid_Compute

#include "RayPlaneIntersection.compute"

static const float3 GridNormalLeft = float3(-1, 0, 0);
static const float3 GridNormalRight = float3(1, 0, 0);
static const float3 GridNormalUp = float3(0, 1, 0);
static const float3 GridNormalDown = float3(0, -1, 0);
static const float3 GridNormalBack = float3(0, 0, -1);
static const float3 GridNormalForward = float3(0, 0, 1);

struct SpatialGridIndex
{
    int x;
    int y;
    int z;
};

struct SpatialGrid
{
    float3 min;
    float3 max;
    float dimension;
    
    float w;    // Grid Width
    float h;    // Grid Height
    float d;    // Grid Depth
};

struct GridStep
{
    int x;
    int y;
    int z;
};


SpatialGrid CreateSpatialGrid(float3 min, float3 max, float dimension)
{
    SpatialGrid grids;
    
    grids.min = min;
    grids.max = max;
    grids.dimension = dimension;
    
    grids.w = (grids.max.x - grids.min.x) / dimension;
    grids.h = (grids.max.y - grids.min.y) / dimension;
    grids.d = (grids.max.z - grids.min.z) / dimension;
    
    return grids;
};


SpatialGridIndex GetGridIndexAtPoint(SpatialGrid grid, float3 pt)
{
    int d = grid.dimension;

    SpatialGridIndex index;
    
    index.x = floor((pt.x - grid.min.x) / (grid.max.x - grid.min.x) * d);
    index.x = clamp(index.x, 0, d - 1);
    index.y = floor((pt.y - grid.min.y) / (grid.max.y - grid.min.y) * d);
    index.y = clamp(index.y, 0, d - 1);
    index.z = floor((pt.z - grid.min.z) / (grid.max.z - grid.min.z) * d);
    index.z = clamp(index.z, 0, d - 1);
    
    return index;
};


void InnerDistanceToBoundary(Ray ray, SpatialGrid grids, GridStep steps, float3 min, float3 max, inout RayHit rayHitX, inout RayHit rayHitY, inout RayHit rayHitZ)
{
    if(steps.x >= 0)
    {
        rayHitX = RayPlaneIntersection(ray, GridNormalLeft, max);
    }
    else
    {
        rayHitX = RayPlaneIntersection(ray, GridNormalRight, min);
    }
    
    if(steps.y >= 0)
    {
        rayHitY = RayPlaneIntersection(ray, GridNormalDown, max);
    }
    else
    {
        rayHitY = RayPlaneIntersection(ray, GridNormalUp, min);
    }
    
    if(steps.z >= 0)
    {
        rayHitZ = RayPlaneIntersection(ray, GridNormalBack, max);
    }
    else
    {
        rayHitZ = RayPlaneIntersection(ray, GridNormalForward, min);
    }
};


/*
float3 GetDeltaToBoundary(SpatialGridIndex entryGridIndex, Ray entryToBoundaryRay, GridStep steps)
{
    
};
*/

#endif  // Spatial_Grid_Compute