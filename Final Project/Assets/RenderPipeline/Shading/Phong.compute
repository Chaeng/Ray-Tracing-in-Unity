#include "../Shadow/Shadow.compute"

static const float PI = 3.14159265f;

float3 PhongDiffuseShading(float3 lightDir, float3 lightColor, float3 hitNormal)
{
    float nDotL = dot(hitNormal, lightDir);
    if(nDotL < 0)
    {
        nDotL = 0;
    }
    return lightColor * nDotL;
}

float3 PhongSpecularShading(float3 lightDir, float3 lightColor, float3 rayDir, float3 hitNormal, float shinyness)
{
    float3 R = reflect(-1 * lightDir, hitNormal);
    float vDotR = dot(-1 * rayDir, R);
    if(vDotR < 0)
    {
        vDotR = 0;
    }
    return pow(vDotR, shinyness) * lightColor;
}

float3 Shade(
    inout Ray ray,
    RayHit hit,
    float3 ambientColor,
    int numOfDirLight,
    StructuredBuffer<RTDirectionalLight> dirLights,
    int numOfPointLight,
    StructuredBuffer<RTPointLight> pointLights,
    int numOfSpotLight,
    StructuredBuffer<RTSpotLight> spotLights,
    Texture2D<float4> skybox,
    SamplerState skyboxSampler,
    int numOfSphere,
    StructuredBuffer<RTSphere> spheres,
    int numOfTriangle,
    StructuredBuffer<RTTriangle> triangles,
    Texture2DArray<float4> shadowMap,
    StructuredBuffer<RTSpotLight_UW> shadowUtility)
{

    if (hit.distance < 1.#INF)
    {
        float3 color = ambientColor;
        float3 tempColor;
        float visibility;
        
        for(int d = 0; d < numOfDirLight; d++)
        {
            tempColor  =   PhongDiffuseShading(dirLights[d].direction, dirLights[d].color, hit.normal) 
                         + PhongSpecularShading(dirLights[d].direction, dirLights[d].color, ray.direction, hit.normal, 5);
            
            visibility = HardShadow(hit.position, 0, dirLights[d].direction, dirLights[d].direction, 
                                              hit.GeoType, hit.GeoIndex, numOfSphere, spheres, numOfTriangle, triangles); 
            color = color + (tempColor * visibility);
        }
        
        for(int p = 0; p < numOfPointLight; p++)
        {
            float3 L = normalize(pointLights[p].position - hit.position);
            tempColor =   PhongDiffuseShading(L, pointLights[p].color, hit.normal) 
                        + PhongSpecularShading(L, pointLights[p].color, ray.direction, hit.normal, 5);
            
            visibility = HardShadow(hit.position, 1, pointLights[p].position, pointLights[p].position,
                                              hit.GeoType, hit.GeoIndex, numOfSphere, spheres, numOfTriangle, triangles); 
           
            color = color + (tempColor * visibility);
        } 
        
        for (int s = 0; s < numOfSpotLight; s++)
        {
            float3 L = normalize(spotLights[s].position - hit.position);
            float cosLtoLightDir = dot(-1 * L, -1 * spotLights[s].direction);
            
            //TODO: Optimize by get rid of conditional statement
            if(cosLtoLightDir >= spotLights[s].cosConeAngle)
            {
                tempColor = PhongDiffuseShading(L, spotLights[s].color, hit.normal)
                            + PhongSpecularShading(L, spotLights[s].color, ray.direction, hit.normal, 1);
                
                bool useDepthMap = false;

                if (useDepthMap)
                {
                    visibility = SoftShadow(hit.position, hit.GeoType, hit.GeoIndex, s, spotLights[s], shadowMap, shadowUtility[s]);
    
                }
                else
                {
                    visibility = HardShadow(hit.position, 2, spotLights[s].position, spotLights[s].direction,
                                                  hit.GeoType, hit.GeoIndex, numOfSphere, spheres, numOfTriangle, triangles);
                }
                
                color = color + (tempColor * visibility);
            }
        
            
        }
        
        return color;
    }
    else
    {
        // Sample the skybox and write it
        float theta = acos(ray.direction.y) / -PI;
        float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f;
        return skybox.SampleLevel(skyboxSampler, float2(phi, theta), 0).xyz;
    }
}


